* Введение
- Emacs — это однопоточный интерактивный редактор с «командным циклом». По умолчанию ваш Lisp‑код выполняется последовательно в главном потоке. Асинхронные события (процессы, сеть, таймеры) обрабатываются, когда Emacs «ждёт» ввода/вывода: между командами, при accept-process-output/sit-for/read-event и т. п.
- «Асинхронность» в Emacs — это архитектурно про внешние процессы и событийную модель, а не про многопоточность общего интерпретатора. Потоки Emacs Lisp кооперативны и защищены глобальной блокировкой: одновременно исполняется только один поток Lisp‑кода.
- Практический принцип:
  - Всё, что может блокировать или долго считаться на CPU, выносите во внешний процесс (make-process/start-process) или в отдельный Emacs (async.el).
  - В главном потоке держите колбэки (фильтры/сентинелы/таймеры) максимально быстрыми: складывайте данные, сигнализируйте «готово», откладывайте тяжёлую обработку на потом (например, через run-at-time 0).
  - Помните про «точки ожидания»: если ваш код долго не уступает управление (не вызывает read-event/accept-process-output/sit-for/проч.), то события и таймеры накапливаются и исполнятся позже, разом.

* Как писать асинхронный Emacs Lisp

** Асинхронные процессы и сеть
- Вызывайте внешние программы и получайте вывод через фильтры и «сентинелы».
- Подходит для I/O: git, grep, потоковая сеть, HTTP и т. п.
- Дешевле и надёжнее, чем «параллелить» Lisp‑код: ОС справится с реальным параллелизмом.

Пример:
#+begin_src elisp
;; -*- lexical-binding: t; -*-
(require 'subr-x) ;; для string-trim

(let* ((buf  (generate-new-buffer " *ls*"))
       (proc (make-process
              :name "ls"
              :buffer buf
              :command '("ls" "-la")
              :noquery t))) ;; не спрашивать при выходе Emacs
  (set-process-filter
   proc
   (lambda (_proc chunk)
     ;; Быстро накапливаем данные в буфере
     (when (buffer-live-p buf)
       (with-current-buffer buf
         (goto-char (point-max))
         (insert chunk)))))
  (set-process-sentinel
   proc
   (lambda (p ev)
     (when (memq (process-status p) '(exit signal))
       (message "[%s] %s" (process-name p) (string-trim ev))
       ;; Безопасно обработать итоговый результат батчем:
       (when (buffer-live-p buf)
         (with-current-buffer buf
           (message "Размер вывода: %d байт" (buffer-size)))
         (kill-buffer buf))))))
#+end_src

Полезное:
- set-process-filter, set-process-sentinel
- process-live-p, accept-process-output (подождать данных, не блокируя UI)
- make-network-process / open-network-stream для сокетов
- url-retrieve для асинхронного HTTP; также библиотеки request.el, plz

** Таймеры
- run-at-time / run-with-idle-timer планируют вызов функции позже или во время простоя.
- Важно: код таймера исполняется в главном потоке. Тяжёлая работа внутри таймера блокирует UI.
- Таймеры и события процесса исполняются в «точках ожидания» Emacs; если код непрерывно занят, таймеры сработают позже.

Примеры:
#+begin_src elisp
;; Сработает через 0.5 секунды
(run-at-time 0.5 nil (lambda () (message "Полсекунды прошло")))

;; Выполнить во время простоя (когда пользователь ничего не делает)
(run-with-idle-timer 1.0 nil
                     (lambda () (message "Сработал idle-таймер")))
#+end_src

** «Асинхронный run-at-time» на базе async.el
- Идея: по таймеру запустить вычисление в отдельном Emacs‑процессе и обработать результат колбэком. Это даёт реальный параллелизм относительно главного Emacs.

#+begin_src elisp
;; -*- lexical-binding: t; -*-
(require 'async)
(require 'cl-lib)

(cl-defun async-run-at-time (time repeat thunk &key callback coalesce)
  "Как =run-at-time', но THUNK выполняется в отдельном Emacs-процессе.
TIME и REPEAT как в =run-at-time'. CALLBACK вызывается в основном Emacs с результатом.
Если COALESCE не-nil, новый запуск пропускается, пока предыдущий не завершён.
Возвращает объект таймера; отмена до старта — =cancel-timer'."
  (let ((running nil))
    (run-at-time
     time repeat
     (lambda ()
       (when (or (not coalesce) (not running))
         (setq running t)
         (async-start
          thunk
          (lambda (res)
            (setq running nil)
            (when callback
              (funcall callback res)))))))))

;; Пример:
(async-run-at-time
  2 nil
  (lambda ()
    ;; Этот код исполняется в ДРУГОМ Emacs.
    ;; Подключайте зависимости явно:
    (require 'subr-x)
    (sleep-for 1)
    (list :pid (emacs-pid) :ts (current-time-string)))
  :callback (lambda (res)
              (message "Готово из async: %S" res))
  :coalesce t)
#+end_src

- Для внешних программ используйте таймер + make-process (см. ниже), а не async.el, если Lisp‑вычисления не нужны.

** Потоки Emacs Lisp (Emacs 26+)
- make-thread, thread-yield, thread-join, make-mutex, condition-variable.
- Кооперативные; глобальная блокировка не даёт параллелить CPU‑нагрузку. Полезны для координации ожиданий, таймаутов, неблокирующего «ждать что-то».
- UI/редисплей делайте в главном потоке (планируйте через run-at-time 0 или таймер).

Пример «фоновая работа → обновить UI», без блокировки главного потока:
#+begin_src elisp
;; -*- lexical-binding: t; -*-
(make-thread
 (lambda ()
   ;; имитация вычислений
   (dotimes (_ 5)
     (sleep-for 0.2)
     (thread-yield))
   (let ((result "готово"))
     ;; UI-обновление в главном потоке
     (run-at-time 0 nil
                  (lambda (r) (message "Результат потока: %s" r))
                  result))))
#+end_src

** Замечания по потокам
- Потоки не ускоряют CPU-задачи.
- Избегайте сложных UI‑операций из потока; любые взаимодействия с окнами/буферами — через планирование в главный поток.
- Для разделяемого состояния используйте mutex/condition-variable; держите критические секции короткими.

** Реальный параллелизм

1) Внешние процессы
- Самый надёжный путь разгрузить Emacs; ОС даст реальную многопоточность.
- make-process/start-process для запуска; фильтры/сентинелы — для обратной связи.

Пример запуска по таймеру и последующей отмены:
#+begin_src elisp
;; -*- lexical-binding: t; -*-
(let (proc timer)
  (setq timer
        (run-at-time
         1 nil
         (lambda ()
           (setq proc (start-process "ping" "*ping*"
                                     "ping" "-c" "3" "example.org"))
           (set-process-query-on-exit-flag proc nil)
           (set-process-filter
            proc (lambda (_ out) (message "[ping] %s" out)))
           (set-process-sentinel
            proc (lambda (p ev) (message "[ping %s] %s" (process-status p) ev))))))

  ;; Пример отмены:
  ;; (cancel-timer timer) ;; до запуска
  ;; (when (and proc (process-live-p proc)) (delete-process proc)) ;; после запуска
  )
#+end_src

2) Пакет async.el
- Запускает вычисления в отдельном Emacs; даёт параллелизм и изоляцию.
- Используйте async-start для Lisp‑кода; async-start-process — когда нужна внешняя команда с колбэком после завершения.

Пример:
#+begin_src elisp
;; -*- lexical-binding: t; -*-
(require 'async)
(async-start
 (lambda ()
   (sleep-for 1)
   (mapcar #'upcase '("a" "b" "c")))
 (lambda (result)
   (message "Из async: %S" result)))
#+end_src

** Удобные библиотеки для асинхронного стиля
- request.el — HTTP c колбэками/промисами.
- plz — современная обёртка поверх url.c (Emacs 29+) с простым API.
- deferred.el / promise.el — примитивы промисов.
- aio.el — async/await‑подобный синтаксис поверх промисов.

** Когда что выбирать
- Сеть/внешние команды, потоковый ввод/вывод — процессы + фильтры/сентинелы.
- «Сделать позже» и лёгкие действия — таймеры; тяжёлое по таймеру — через async.el или внешний процесс.
- Координация ожиданий без блокировки UI — потоки Emacs Lisp (аккуратно с UI).
- Тяжёлые CPU‑задачи — внешний процесс или отдельный Emacs (async.el).
- Периодические задачи (repeat): используйте «coalesce»/флаг занятости, чтобы не запускать параллельные экземпляры.

** Справка в Emacs
- M-x info → Elisp → Processes (Asynchronous Processes)
- M-x info → Elisp → Timers
- M-x info → Elisp → Threads

* Ключевые плюсы однопоточности (с глобальной блокировкой) в Emacs Lisp
** Простая модель исполнения
- Код выполняется «целиком», события приходят в «точках ожидания». Меньше неявной реэнтрантности.

** Безопасность и целостность редакторских структур
- Буферы/окна не модифицируются конкурентно из другого интерпретатора.

** Меньше синхронизации и оверхеда
- Ядро и экосистема упрощены: нет необходимости повсеместных блокировок.

** Предсказуемый UI и атомарность команд
- Пользователь видит консистентные изменения после каждой команды.

** Проще отладка и воспроизводимость
- Последовательность облегчает трассировку, Edebug, воспроизведение багов.

** Удобная динамическая конфигурация через let‑binding
- Динамически связанные переменные ведут себя локально и прозрачно.

** GC и память без межпоточных барьеров
- Проще реализация, меньше накладных расходов.

** Устойчивая интеграция экосистемы
- Совместимость с тысячами пакетов, писавшихся под эту модель.

** Реальный параллелизм — через процессы, а не общую память
- Тяжёлые задачи выносите во внешние процессы или отдельный Emacs; изоляция повышает надёжность.

* Практические следствия
- Пишите «долгие» операции так, чтобы явно уступать управление (accept-process-output/sit-for/run-at-time).
- Минимизируйте работу фильтров/сентинелов/таймеров; переносите тяжёлое на потом.
- Для CPU‑тяжёлого — отдельный процесс; для I/O — асинхронные процессы/сокеты.
- Для периодических задач — коалесцируйте запуски, защищайте состояние.

* отличия асинхронности Emacs Lisp от модели асинхронности Javascript
Коротко: JS — «event loop + macrotask/microtask + Promises/async‑await»; Emacs — «командный цикл + процессы/сокеты + таймеры + кооперативные потоки», без микрозадач и без параллельного исполнения Lisp‑кода в одном интерпретаторе.

** Базовая модель
- JavaScript: один поток JS на event loop; задачи run‑to‑completion, async/await — часть языка, промисы — стандарт.
- Emacs Lisp: основной «командный цикл»; асинхронность строится на:
  - внешних процессах/сетевых сокетах с фильтрами/сентинелами;
  - таймерах (включая idle);
  - кооперативных lisp‑потоках.
  Промисы не встроены — доступны библиотеками (promise.el, deferred.el, aio.el).

** Параллелизм
- JS: реальный параллелизм — Workers/worker_threads; память обычно изолирована.
- Emacs Lisp: несколько lisp‑потоков, но с глобальной блокировкой; реальный параллелизм — только через внешние процессы или отдельный Emacs (async.el).

** I/O
- JS: браузер — всегда неблокирующее I/O; Node — libuv, асинхронные примитивы.
- Emacs: многие вызовы синхронны и могут блокировать UI; неблокирующие — через процессы/сокеты/url‑stack и колбэки.

** Планирование и очереди
- JS: macrotask/microtask, гарантии порядка для then/await.
- Emacs: микрозадач нет; события исполняются при ожидании. Если код не уступает управление, задержки растут.

** «Run-to-completion»
- JS: колбэки не прерывают выполняющийся синхронный JS.
- Emacs: обычный Lisp‑код не прерывается, но явные «ожидания» допускают исполнение таймеров/фильтров.

** UI и «главный поток»
- JS: DOM — только в главном потоке.
- Emacs: redisplay/ввод — только в главном; фоновые потоки должны планировать UI‑работу в главный.

** Ошибки в асинхронном коде
- JS: исключения в async → rejected Promise, есть unhandledrejection.
- Emacs: ошибки в фильтрах/таймерах/сентинелах не поднимутся «вверх», уходят в /Messages/ (в отладке — debug-on-error).

** Синхронизация и разделяемое состояние
- JS: обмен сообщениями; SharedArrayBuffer + Atomics — исключение.
- Emacs: общая память между потоками, но глобальная блокировка; mutex/condvar для координации.

** Отмена
- JS: AbortController/AbortSignal — стандарт.
- Emacs: cancel-timer, delete-process/kill-process; для async.el — проектируйте идемпотентные задачи или управляйте окружением процесса.

** Практические последствия
- JS: CPU — в Worker; Emacs: CPU — во внешний процесс/отдельный Emacs.
- JS: fetch/Promises; Emacs: url-retrieve/request.el/plz + колбэки/промисы (aio.el).
- Таймеры: JS — setTimeout/setInterval/queueMicrotask; Emacs — run-at-time/run-with-idle-timer/accept-process-output.

** Если вы «мысленно переносите» JS‑подход в Emacs
- Промисы/await реализуемы библиотеками, но «микрозадачной» очереди нет — колбэки исполняются в «точках ожидания».
- Не делайте тяжёлых вещей в фильтрах/таймерах; реальный параллелизм — через процессы/async.el.

* Примечания к примерам
- Все примеры предполагают -*- lexical-binding: t; -*- (ставьте в начале файла/блока).
- Фильтры/сентинелы должны быть быстрыми: минимум аллокаций, без тяжёлого redisplay; оборачивайте в condition-case для устойчивости; логируйте ошибки.
- Управление процессами:
  - set-process-query-on-exit-flag/ :noquery t для «тихих» воркеров;
  - на большие объёмы данных влияет read-process-output-max;
  - process-connection-type nil (pipe) может быть быстрее, чем pty.
- Таймеры/события исполняются только при «ожидании» Emacs. Долгие синхронные вычисления без уступки управления задерживают всё остальное.
- async.el и окружение:
  - В дочернем Emacs явно (require ...) зависимости; результат должен быть сериализуемым prin1/read;
  - На NixOS удостоверьтесь, что дочерний Emacs видит нужные пакеты (PATH/EMACS/EMACSLOADPATH либо используйте фиксированный бинарь).
- Периодические задачи: при repeat используйте коалесценцию (как :coalesce в async-run-at-time) или «флаг занято».
- Управление буферами: создавая временные буферы под процессы, удаляйте их в sentinel, когда работа завершена.
