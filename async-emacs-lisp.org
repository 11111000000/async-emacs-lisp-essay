*** Как писать асинхронный Emacs Lisp

1) Асинхронные процессы и сеть
- Вызывайте внешние программы и получайте вывод через фильтры и «сентинелы».
- Подходит для I/O: git, grep, ленты сети, HTTP и т. п.

Пример:
#+begin_src 

(let ((buf (generate-new-buffer " /ls/")))
  (make-process
   :name "ls"
   :buffer buf
   :command '("ls" "-la")
   :filter (lambda (_proc chunk)
             ;; обрабатываем пришедший кусок
             (with-current-buffer buf
               (goto-char (point-max))
               (insert chunk)))
   :sentinel (lambda (_proc event)
               (when (string-match-p "finished" event)
                 (message "Готово: %s" (buffer-string))))))
#+end_src

Полезное:
- set-process-filter, set-process-sentinel
- process-live-p, accept-process-output (подождать данных, не блокируя UI)
- make-network-process / open-network-stream для сокетов
- url-retrieve для асинхронного HTTP (или библиотека request.el)

2) Таймеры
- run-at-time / run-with-idle-timer
- Планируют вызов функции позже или во время простоя, не блокируя редактор.

Пример:
(run-at-time 0.5 nil (lambda () (message "Полсекунды прошло")))

3) Потоки Emacs Lisp (Emacs 26+)
- make-thread, thread-yield, thread-join, make-mutex, condition-variable.
- Они кооперативные и защищены глобальной блокировкой: в каждый момент времени исполняется только один поток Lisp-кода.
- Хорошо подходят, чтобы «ждать что-то» (I/O, ожидания, таймауты), не подвешивая UI; не годятся для ускорения чисто CPU‑нагрузки.

Пример вычисления в фоне с последующим обновлением UI:
#+begin_src 

(let ((thr
       (make-thread
        (lambda ()
          ;; имитация долгой работы
          (dotimes (i 5)
            (sleep-for 0.5)
            (thread-yield))
          (let ((result "готово"))
            ;; обновляем UI через очередь главного потока
            (run-at-time 0 nil
                         (lambda (r) (message "Результат: %s" r))
                         result))))))
  (thread-join thr))
#+end_src

Замечания по потокам:
- Не рассчитывайте на ускорение CPU-задач: глобальная блокировка не даст двум потокам выполнять Lisp одновременно.
- Лучше избегать сложных UI/редисплей-операций из фоновых потоков; планируйте их в главный поток через run-at-time 0 или таймер.
- Используйте mutex/condvar при разделении состояния между потоками.

Реальный параллелизм

1) Внешние процессы
- Самый надёжный путь разгрузить Emacs и получить многопоточность на уровне ОС.
- make-process/start-process для запуска; фильтры/сентинелы для обратной связи.

2) Пакет async.el
- Запускает вычисления в отдельном процессе Emacs.
- Даёт «настоящий» параллелизм и не блокирует главный Emacs.

Пример:
#+begin_src 

(require 'async)
(async-start
 (lambda ()
   (sleep-for 2)
   (mapcar #'upcase '("a" "b" "c")))
 (lambda (result)
   (message "Из async: %S" result)))

Удобные библиотеки для асинхронного стиля
- request.el — удобный HTTP с колбэками/промисами.
- deferred.el / promise.el — промисы.
- aio.el — async/await-подобный синтаксис поверх промисов.
#+end_src

Когда что выбирать
- Сеть/внешние команды, потоковый ввод/вывод — процессы + фильтры/сентинелы.
- «Сделать позже», «не мешать UI» — таймеры.
- Координация ожиданий без блокировки UI — потоки Emacs Lisp, но аккуратно с UI и без ожиданий ускорения.
- Тяжёлые CPU-задачи, парсинг больших объёмов, сжатие и т. п. — отдельные процессы (make-process) или async.el.

Справка в Emacs
- M-x info → Elisp → Processes (Asynchronous Processes)
- M-x info → Elisp → Timers
- M-x info → Elisp → Threads

*** Ключевые плюсы однопоточности (с глобальной блокировкой) в Emacs Lisp:

**** Простая модель исполнения
  - Код выполняется «целиком» и не прерывается посреди формы обычным образом. Таймеры/фильтры запускаются только в «точках ожидания» (например, accept-process-output, sit-for, чтение ввода).
  - Локально рассуждать о состоянии проще: переменные и буферы не меняются «сами по себе», пока вы явно не уступили управление.

**** Безопасность и целостность редакторских структур
  - Буферы, окна, переменные и хеш‑таблицы не модифицируются конкурентно из другого потока.
  - Меньше гонок, дедлоков и тонких багов вокруг before/after-change‑hooks, точек, оверлеев и т. п.

**** Меньше синхронизации и оверхеда
  - Нет необходимости оборачивать каждую структуру блокировками; ядро и большинство пакетов не несут стоимость «потокобезопасности».
  - Проще и быстрее реализация многих примитивов (редисплей, текстовые операции, хуки).

**** Предсказуемый UI и атомарность команд
  - Пользователь видит целостные изменения: команда отработала — состояние консистентно.
  - Меньше мерцаний и «разъезжаний» состояния от состязаний нескольких одновременно работающих обработчиков.

**** Проще отладка и воспроизводимость
  - Последовательное выполнение облегчает трассировку, запись/воспроизведение сценариев, использование Edebug/trace, анализ сообщений.
  - Ошибки не зависят от порядка планирования потоков.

**** Удобная динамическая конфигурация через let‑binding
  - В Emacs широко используются динамически связанные переменные (например, case-fold-search, inhibit-redisplay). В однопоточном исполнении их действие локально и прозрачно, без утечек в параллельные контексты.

**** GC и память без межпоточных барьеров
  - Сборщик мусора проще, нет накладных расходов на кросс‑поточные барьеры и сложные протоколы «безопасных точек».

**** Устойчивая интеграция экосистемы
  - Тысячи пакетов исторически написаны с расчётом на последовательное исполнение; совместимость выше, меньше скрытых предположений нарушается.

**** Реальный параллелизм — через процессы, а не общую память
  - Тяжёлые задачи выносятся во внешние процессы (make-process, async.el). Это повышает изоляцию и надёжность: краш воркера не валит Emacs, нет shared‑memory гонок.

*** Практические следствия:
- Пишите «долгие» операции так, чтобы явно уступать управление в контролируемых местах (accept-process-output/sit-for/run-at-time), и вы сохраните и отзывчивость UI, и простоту reasoning.
- Не нужны сложные схемы синхронизации вокруг буфера: save-excursion/save-restriction/let‑binding обычно достаточно для «критических секций».
- Для CPU‑тяжёлого — отдельный процесс; для I/O — асинхронные процессы/сокеты с фильтрами. Так вы сохраняете плюсы однопоточности и всё же получаете параллельность там, где она действительно нужна.

***  отличия асинхронности Emacs Lisp от модели асинхронности Javascript

Коротко: JS — строгий «event loop + Promises/async‑await» с одним потоком выполнения на цикл; Emacs Lisp — «командный цикл + процессы/таймеры/кооперативные потоки», без встроенных промисов и без параллелизма внутри интерпретатора. Подробности по пунктам:

**** Базовая модель
- JavaScript: один поток JS на event loop. Задачи выполняются «run‑to‑completion», асинхронность — через задачи (macrotask) и микрозадачи (Promises). async/await — часть языка.
- Emacs Lisp: основной «командный цикл» редактора. Асинхронность строится на:
  - внешних процессах/сетевых сокетах с фильтрами и «сентинелами»;
  - таймерах (в т.ч. idle‑таймерах);
  - кооперативных lisp‑потоках (Emacs 26+).
  Промисы/async‑await в ядро не встроены; доступны библиотеками (promise.el, deferred.el, aio.el).

**** Параллелизм
- JS: по умолчанию нет; для CPU — Web Workers/worker_threads (реальный параллелизм). Память обычно изолирована; SharedArrayBuffer + Atomics — редкое исключение.
- Emacs Lisp: несколько lisp‑потоков, но с глобальной блокировкой — одновременно исполняется только один поток Lisp (нет ускорения CPU). Реальный параллелизм — через внешние процессы (make-process) или отдельный Emacs-процесс (async.el).

**** I/O
- JS: браузер — только неблокирующее I/O; Node — есть и async, и sync (sync блокирует event loop).
- Emacs: многие операции синхронные и блокируют UI (чтение файлов, парсинг и т.п.). Для неблокирующего I/O используют make-process/open-network-stream/url-retrieve; колбэки (фильтры/сентинелы) должны быть очень быстрыми.

**** Планирование и очереди
- JS: стандартизованные очереди macrotask/microtask; промисы всегда исполняют then/await в microtask‑фазе.
- Emacs: микрозадач нет. Таймеры и события процесса обрабатываются, когда Emacs «ждёт» (между командами, при accept-process-output/sit-for/read-event и т.п.). Если код непрерывно занят, события копятся — это влияет на латентность.

**** «Run-to-completion»
- JS: колбэки никогда не прерывают выполняющийся синхронный JS.
- Emacs: обычный Lisp‑код тоже не прерывается, но многие функции явно уступают управлением (например, accept-process-output, sit-for, sleep-for), и тогда могут выполниться фильтры/таймеры. То есть точек реэнтрантности больше под вашим контролем.

**** UI и «главный поток»
- JS: DOM доступен только из главного потока; Workers — без DOM.
- Emacs: отображение/миннибуфер — только в главном «UI‑потоке». Lisp‑потоки не должны делать redisplay/ввод; обновляйте UI через планирование в главный поток (run-at-time 0, таймер).

**** Ошибки в асинхронном коде
- JS: исключения в async превращаются в rejected Promise; есть глобальный обработчик unhandledrejection.
- Emacs: ошибка в фильтре/сентинеле/таймере не «поднимется» к вызывавшему коду; она логируется в /Messages/ (для отладки — debug-on-error). Единого механизма «необработанного отклонения» нет.

**** Синхронизация и разделяемое состояние
- JS: обычно обмен сообщениями; SharedArrayBuffer + Atomics — низкоуровневые примитивы, mutex’ов в языке нет.
- Emacs: все lisp‑потоки разделяют память/буферы; есть mutex и condition-variable. Из‑за глобальной блокировки они чаще нужны для координации, чем для защиты от гонок.

**** Отмена
- JS: AbortController/AbortSignal — стандарт, поддерживается множеством API.
- Emacs: отмена «вручную» — kill-process/delete-process, cancel-timer; общесистемного токена отмены нет (библиотеки могут добавлять свой).

*** Практические последствия
**** Тяжёлые CPU‑задачи:
  - JS: выносите в Worker/worker_threads.
  - Emacs: выносите в внешние процессы (make-process) или в отдельный Emacs через async.el. Потоки Emacs не ускорят.
**** Сеть/процессы:
  - JS: fetch/Promises/async‑await.
  - Emacs: url-retrieve/request.el + колбэки/промисы из aio.el/promise.el.
**** Таймеры:
  - JS: setTimeout/setInterval/queueMicrotask.
  - Emacs: run-at-time/run-with-idle-timer/accept-process-output.

Если вы «мысленно переносите» JS‑подход в Emacs:
- Промисы/await можно получить с aio.el/promise.el, но выполнение колбэков привязано к «точкам ожидания» Emacs, а не к строго определённой microtask‑очереди.
- Не делайте тяжёлых вещей в фильтрах/таймерах — они блокируют весь Emacs.
- Для настоящей параллельной работы используйте отдельные процессы, а не lisp‑потоки.

  
